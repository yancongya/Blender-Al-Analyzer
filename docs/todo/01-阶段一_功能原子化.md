# 阶段一：现有功能"原子化"抽象

**文档版本**: 1.0.0
**创建日期**: 2026-01-13
**预计时间**: 2-3 天

---

## 1. 目标

将现有功能重构为独立的、可复用的模块，确保它们可以被 MCP 服务器独立调用，同时保持与现有代码的兼容性。

## 2. 模块清单

| 模块名称 | 文件路径 | 对应现有函数 | 优先级 |
|----------|----------|-------------|--------|
| 资产检索模块 | `backend/core/hierarchy.py` | 无（新建） | 高 |
| 模块定位模块 | `backend/core/module_fetcher.py` | 无（新建） | 高 |
| 节点过滤模块 | `backend/core/node_filter.py` | `filter_node_description()` | 高 |
| 节点解析模块 | `backend/core/node_parser.py` | `parse_node_tree_recursive()` | 高 |
| 配置读取模块 | `backend/core/config_reader.py` | 无（新建） | 中 |

## 3. 详细实现

### 3.1 资产检索模块 (`hierarchy.py`)

#### 功能描述

遍历 `bpy.data`，返回包含几何节点组、材质、合成、世界环境的路径化树状图。

#### 函数签名

```python
def get_hierarchy(
    include_geometry: bool = True,
    include_materials: bool = True,
    include_compositor: bool = True,
    include_world: bool = True,
    include_textures: bool = True
) -> dict:
    """
    获取 Blender 资产的层级结构
    
    Args:
        include_geometry: 是否包含几何节点组
        include_materials: 是否包含材质
        include_compositor: 是否包含合成节点树
        include_world: 是否包含世界环境
        include_textures: 是否包含纹理节点树
    
    Returns:
        dict: 资产层级结构
        {
            "status": "Success",
            "data": {
                "Geometry Nodes": {...},
                "Materials": {...},
                ...
            }
        }
    """
```

#### 输入参数

| 参数 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `include_geometry` | bool | True | 是否包含几何节点组 |
| `include_materials` | bool | True | 是否包含材质 |
| `include_compositor` | bool | True | 是否包含合成节点树 |
| `include_world` | bool | True | 是否包含世界环境 |
| `include_textures` | bool | True | 是否包含纹理节点树 |

#### 输出格式

```json
{
    "status": "Success",
    "data": {
        "Geometry Nodes": {
            "MyGeometryGroup": {
                "path": "Geometry Nodes/MyGeometryGroup",
                "type": "geometry",
                "node_count": 15
            }
        },
        "Materials": {
            "Gold_Mat": {
                "path": "Materials/Gold_Mat",
                "type": "material",
                "node_count": 8
            }
        },
        "Compositor": {
            "MainComp": {
                "path": "Compositor/MainComp",
                "type": "compositor",
                "node_count": 12
            }
        },
        "World": {
            "WorldEnvironment": {
                "path": "World/WorldEnvironment",
                "type": "world",
                "node_count": 5
            }
        },
        "Textures": {
            "MyTexture": {
                "path": "Textures/MyTexture",
                "type": "texture",
                "node_count": 3
            }
        }
    }
}
```

#### 实现要点

1. 遍历 `bpy.data.node_groups` 获取几何节点组
2. 遍历 `bpy.data.materials` 获取材质
3. 遍历 `bpy.data.scenes` 获取合成节点树
4. 遍历 `bpy.data.worlds` 获取世界环境
5. 遍历 `bpy.data.textures` 获取纹理节点树
6. 统计每个资产的节点数量
7. 生成路径化标识符

#### 测试用例

```python
# 测试 1: 获取所有资产
result = get_hierarchy()
assert result["status"] == "Success"
assert "Geometry Nodes" in result["data"]

# 测试 2: 仅获取材质
result = get_hierarchy(include_materials=True, include_geometry=False, ...)
assert result["status"] == "Success"
assert "Materials" in result["data"]
assert "Geometry Nodes" not in result["data"]
```

---

### 3.2 模块定位模块 (`module_fetcher.py`)

#### 功能描述

根据路径字符串精准定位 Blender 内部的数据块 (Data-Block)。

#### 函数签名

```python
def fetch_module(path: str) -> dict:
    """
    根据路径定位 Blender 数据块
    
    Args:
        path (str): 资产路径，格式为 "Category/Name"
    
    Returns:
        dict: 数据块信息
        {
            "status": "Success",
            "data": {
                "path": "Materials/Gold_Mat",
                "type": "material",
                "name": "Gold_Mat",
                "node_tree": {...}
            }
        }
    """
```

#### 输入参数

| 参数 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `path` | str | 必填 | 资产路径，格式为 "Category/Name" |

#### 支持的路径格式

| 路径格式 | 示例 | 说明 |
|----------|------|------|
| `Geometry Nodes/{name}` | `Geometry Nodes/MyGroup` | 几何节点组 |
| `Materials/{name}` | `Materials/Gold_Mat` | 材质 |
| `Compositor/{name}` | `Compositor/MainComp` | 合成节点树 |
| `World/{name}` | `World/Environment` | 世界环境 |
| `Textures/{name}` | `Textures/MyTexture` | 纹理节点树 |

#### 输出格式

```json
{
    "status": "Success",
    "data": {
        "path": "Materials/Gold_Mat",
        "type": "material",
        "name": "Gold_Mat",
        "node_tree": {
            "name": "Shader Nodetree",
            "bl_idname": "ShaderNodeTree",
            "nodes_count": 8
        }
    }
}
```

#### 实现要点

1. 解析路径字符串，提取类别和名称
2. 根据类别在 `bpy.data` 中查找对应的数据块
3. 返回数据块的基本信息和节点树信息
4. 处理路径不存在的情况

#### 测试用例

```python
# 测试 1: 定位材质
result = fetch_module("Materials/Gold_Mat")
assert result["status"] == "Success"
assert result["data"]["type"] == "material"

# 测试 2: 定位不存在的资产
result = fetch_module("Materials/NonExistent")
assert result["status"] == "Error"
assert "not found" in result["data"]["error"]
```

---

### 3.3 节点过滤模块 (`node_filter.py`)

#### 功能描述

将现有的"过滤节点信息"功能封装为独立模块，接收原始 JSON 和阈值作为输入。

#### 函数签名

```python
def filter_node_data(
    raw_data: dict,
    filter_level: str = "STANDARD"
) -> dict:
    """
    过滤节点数据
    
    Args:
        raw_data (dict): 原始节点数据
        filter_level (str): 过滤级别 (ULTRA_LITE, LITE, STANDARD, FULL)
    
    Returns:
        dict: 过滤后的数据和统计信息
        {
            "status": "Success",
            "data": {
                "filtered_data": {...},
                "original_size": 1024,
                "filtered_size": 256,
                "reduction_ratio": 0.75
            }
        }
    """
```

#### 输入参数

| 参数 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `raw_data` | dict | 必填 | 原始节点数据 JSON |
| `filter_level` | str | "STANDARD" | 过滤级别 |

#### 过滤级别说明

| 级别 | 描述 | 保留内容 |
|------|------|----------|
| `ULTRA_LITE` | 超轻量级 | 仅保留节点名称和类型 |
| `LITE` | 轻量级 | 保留基本信息，移除未连接的输入 |
| `STANDARD` | 标准 | 保留详细信息，移除位置、尺寸等 |
| `FULL` | 完整 | 保留所有信息 |

#### 输出格式

```json
{
    "status": "Success",
    "data": {
        "filtered_data": {
            "nodes": [
                {
                    "name": "TestNode",
                    "type": "ShaderNodeBsdfPrincipled"
                }
            ]
        },
        "original_size": 1024,
        "filtered_size": 256,
        "reduction_ratio": 0.75
    }
}
```

#### 实现要点

1. 从 `__init__.py` 的 `filter_node_description()` 函数提取核心逻辑
2. 根据 `filter_level` 应用不同的过滤策略
3. 统计原始数据和过滤后数据的大小
4. 计算压缩比例

#### 测试用例

```python
# 测试 1: ULTRA_LITE 过滤
test_data = {"nodes": [{"name": "Node1", "type": "Type1", "location": [0, 0]}]}
result = filter_node_data(test_data, "ULTRA_LITE")
assert result["status"] == "Success"
assert "location" not in result["data"]["filtered_data"]["nodes"][0]

# 测试 2: FULL 过滤
result = filter_node_data(test_data, "FULL")
assert result["status"] == "Success"
assert "location" in result["data"]["filtered_data"]["nodes"][0]
```

---

### 3.4 节点解析模块 (`node_parser.py`)

#### 功能描述

将现有的 `parse_node_tree_recursive` 函数封装为独立模块。

#### 函数签名

```python
def parse_node_tree(
    node_tree: bpy.types.NodeTree,
    max_depth: int = 10
) -> dict:
    """
    解析节点树
    
    Args:
        node_tree (bpy.types.NodeTree): Blender 节点树对象
        max_depth (int): 最大递归深度
    
    Returns:
        dict: 解析后的节点树数据
        {
            "status": "Success",
            "data": {
                "tree_type": "ShaderNodeTree",
                "nodes": [...],
                "groups": {...},
                "links": [...]
            }
        }
    """
```

#### 输入参数

| 参数 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `node_tree` | bpy.types.NodeTree | 必填 | Blender 节点树对象 |
| `max_depth` | int | 10 | 最大递归深度 |

#### 输出格式

```json
{
    "status": "Success",
    "data": {
        "tree_type": "ShaderNodeTree",
        "nodes": [
            {
                "name": "Node1",
                "name_localized": "节点1",
                "type": "ShaderNodeBsdfPrincipled",
                "location": [0, 0],
                "inputs": [...],
                "outputs": [...]
            }
        ],
        "groups": {
            "GroupName": {...}
        },
        "links": [
            {
                "from_node": "Node1",
                "from_socket": "Output",
                "to_node": "Node2",
                "to_socket": "Input"
            }
        ]
    }
}
```

#### 实现要点

1. 从 `__init__.py` 的 `parse_node_tree_recursive()` 函数提取核心逻辑
2. 支持递归解析节点组
3. 解析节点的输入和输出端口
4. 解析节点之间的连接
5. 添加本地化支持

#### 测试用例

```python
# 测试 1: 解析材质节点树
material = bpy.data.materials[0]
if material.node_tree:
    result = parse_node_tree(material.node_tree)
    assert result["status"] == "Success"
    assert "nodes" in result["data"]

# 测试 2: 超过最大深度
result = parse_node_tree(material.node_tree, max_depth=0)
assert result["status"] == "Success"
# 应该返回错误或限制深度
```

---

### 3.5 配置读取模块 (`config_reader.py`)

#### 功能描述

根据 config.json 返回对应的专家背景和详略要求文本。

#### 函数签名

```python
def get_config(config_key: str) -> dict:
    """
    读取配置文件
    
    Args:
        config_key (str): 配置键名
    
    Returns:
        dict: 配置数据
        {
            "status": "Success",
            "data": {
                "system_message_presets": [...]
            }
        }
    """
```

#### 输入参数

| 参数 | 类型 | 默认值 | 描述 |
|------|------|--------|------|
| `config_key` | str | 必填 | 配置键名 |

#### 支持的配置键

| 配置键 | 返回内容 |
|--------|----------|
| `system_message_presets` | 系统消息预设列表 |
| `default_question_presets` | 默认问题预设列表 |
| `output_detail_presets` | 输出详细程度预设 |
| `ai` | AI 配置信息 |
| `port` | 服务器端口 |

#### 输出格式

```json
{
    "status": "Success",
    "data": {
        "system_message_presets": [
            {
                "label": "几何节点专家",
                "value": "您是Blender几何节点（Geometry Nodes）的专家..."
            }
        ]
    }
}
```

#### 实现要点

1. 读取插件目录下的 `config.json` 文件
2. 根据键名返回对应的配置数据
3. 处理键不存在的情况
4. 支持嵌套键（如 `ai.deepseek.api_key`）

#### 测试用例

```python
# 测试 1: 读取系统消息预设
result = get_config("system_message_presets")
assert result["status"] == "Success"
assert isinstance(result["data"]["system_message_presets"], list)

# 测试 2: 读取不存在的配置
result = get_config("nonexistent_key")
assert result["status"] == "Error"
```

---

## 4. 实施步骤

### 步骤 1: 创建核心模块目录结构

```bash
mkdir -p backend/core
touch backend/core/__init__.py
```

### 步骤 2: 实现资产检索模块

1. 创建 `backend/core/hierarchy.py`
2. 实现 `get_hierarchy()` 函数
3. 编写单元测试
4. 验证功能正确性

### 步骤 3: 实现模块定位模块

1. 创建 `backend/core/module_fetcher.py`
2. 实现 `fetch_module()` 函数
3. 编写单元测试
4. 验证功能正确性

### 步骤 4: 实现节点过滤模块

1. 创建 `backend/core/node_filter.py`
2. 从 `__init__.py` 提取 `filter_node_description()` 逻辑
3. 实现 `filter_node_data()` 函数
4. 编写单元测试
5. 验证功能正确性

### 步骤 5: 实现节点解析模块

1. 创建 `backend/core/node_parser.py`
2. 从 `__init__.py` 提取 `parse_node_tree_recursive()` 逻辑
3. 实现 `parse_node_tree()` 函数
4. 编写单元测试
5. 验证功能正确性

### 步骤 6: 实现配置读取模块

1. 创建 `backend/core/config_reader.py`
2. 实现 `get_config()` 函数
3. 编写单元测试
4. 验证功能正确性

### 步骤 7: 集成测试

1. 运行所有单元测试
2. 验证模块之间的交互
3. 确保功能与原有实现一致

---

## 5. 验收标准

### 5.1 功能验收

- ✅ 所有模块正常工作
- ✅ 所有单元测试通过
- ✅ 模块之间可以正常交互
- ✅ 功能与原有实现一致

### 5.2 代码质量验收

- ✅ 代码符合 PEP 8 规范
- ✅ 所有函数包含文档字符串
- ✅ 所有函数包含类型提示
- ✅ 所有函数包含异常处理

### 5.3 兼容性验收

- ✅ 不修改现有功能的 API
- ✅ 不影响现有代码的运行
- ✅ 可以独立调用每个模块

---

## 6. 风险与缓解

| 风险 | 影响 | 概率 | 缓解措施 |
|------|------|------|----------|
| 重构引入 bug | 高 | 中 | 充分测试，保留原有代码 |
| 性能下降 | 中 | 低 | 性能测试，优化代码 |
| API 不兼容 | 高 | 低 | 保持 API 签名不变 |

---

**文档结束**
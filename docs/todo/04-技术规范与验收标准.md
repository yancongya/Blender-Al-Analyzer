# 技术规范与验收标准

**文档版本**: 1.0.0
**创建日期**: 2026-01-13

---

## 1. 技术规范

### 1.1 代码风格

#### Python 代码规范

遵循 **PEP 8** 规范：

```python
# 导入顺序
import os          # 标准库
import sys         # 标准库

import bpy         # 第三方库
import flask       # 第三方库

from backend.core import hierarchy  # 本地导入
from backend.mcp import server      # 本地导入

# 函数定义
def function_name(param1: str, param2: int) -> dict:
    """
    函数简短描述
    
    Args:
        param1: 参数1描述
        param2: 参数2描述
    
    Returns:
        dict: 返回值描述
    """
    # 函数体
    pass

# 类定义
class ClassName:
    """类简短描述"""
    
    def __init__(self, param: str):
        """初始化方法"""
        self.param = param
    
    def method_name(self) -> str:
        """方法简短描述"""
        pass
```

#### 命名规范

| 类型 | 命名规范 | 示例 |
|------|----------|------|
| 模块名 | 小写，下划线分隔 | `hierarchy.py`, `module_fetcher.py` |
| 类名 | 大驼峰 | `MCPServer`, `BlenderTaskQueue` |
| 函数名 | 小写，下划线分隔 | `get_hierarchy()`, `fetch_module()` |
| 变量名 | 小写，下划线分隔 | `node_tree`, `filter_level` |
| 常量名 | 大写，下划线分隔 | `MAX_DEPTH`, `DEFAULT_TIMEOUT` |
| 私有成员 | 单下划线前缀 | `_internal_var`, `_private_method()` |

#### 文档字符串

所有公共函数和类必须包含文档字符串：

```python
def get_hierarchy(
    include_geometry: bool = True,
    include_materials: bool = True
) -> dict:
    """
    获取 Blender 资产的层级结构
    
    遍历 bpy.data，返回包含几何节点组、材质、合成、世界环境的路径化树状图。
    
    Args:
        include_geometry: 是否包含几何节点组，默认为 True
        include_materials: 是否包含材质，默认为 True
    
    Returns:
        dict: 资产层级结构
        {
            "status": "Success",
            "data": {
                "Geometry Nodes": {...},
                "Materials": {...}
            }
        }
    
    Raises:
        Exception: 当 Blender 数据访问失败时
    
    Examples:
        >>> result = get_hierarchy(include_geometry=True)
        >>> print(result['status'])
        'Success'
    """
    pass
```

#### 类型提示

所有函数必须包含类型提示：

```python
from typing import Dict, List, Optional, Callable, Any

def filter_node_data(
    raw_data: Dict[str, Any],
    filter_level: str = "STANDARD"
) -> Dict[str, Any]:
    """
    过滤节点数据
    
    Args:
        raw_data: 原始节点数据
        filter_level: 过滤级别
    
    Returns:
        过滤后的数据和统计信息
    """
    pass
```

---

### 1.2 异常处理

#### 异常处理规范

所有函数必须包含异常处理：

```python
def parse_node_tree(node_tree: bpy.types.NodeTree) -> dict:
    """
    解析节点树
    
    Args:
        node_tree: Blender 节点树对象
    
    Returns:
        dict: 解析后的节点树数据
    """
    try:
        # 尝试解析节点树
        result = {
            "status": "Success",
            "data": {
                "nodes": [],
                "links": []
            }
        }
        
        # 解析逻辑
        # ...
        
        return result
        
    except AttributeError as e:
        return {
            "status": "Error",
            "error": f"节点树对象无效: {str(e)}"
        }
    except Exception as e:
        return {
            "status": "Error",
            "error": f"解析节点树时出错: {str(e)}"
        }
```

#### 日志记录

使用 `logging` 模块记录重要事件：

```python
import logging

logger = logging.getLogger(__name__)

def handle_request(request: dict) -> dict:
    """
    处理 MCP 请求
    
    Args:
        request: JSON-RPC 请求
    
    Returns:
        dict: JSON-RPC 响应
    """
    logger.info(f"收到请求: {request}")
    
    try:
        # 处理请求
        result = process_request(request)
        logger.info(f"请求处理成功")
        return result
        
    except Exception as e:
        logger.error(f"请求处理失败: {str(e)}", exc_info=True)
        return {
            "status": "Error",
            "error": str(e)
        }
```

---

### 1.3 线程安全

#### 线程安全规范

所有共享资源必须使用锁保护：

```python
import threading

class SharedResource:
    """共享资源类"""
    
    def __init__(self):
        self.data = {}
        self.lock = threading.Lock()
    
    def set_value(self, key: str, value: Any) -> None:
        """设置值"""
        with self.lock:
            self.data[key] = value
    
    def get_value(self, key: str) -> Optional[Any]:
        """获取值"""
        with self.lock:
            return self.data.get(key)
    
    def clear(self) -> None:
        """清空数据"""
        with self.lock:
            self.data.clear()
```

#### Blender API 调用

所有 Blender API 调用必须在主线程执行：

```python
import bpy

class BlenderTaskQueue:
    """Blender 主线程任务队列"""
    
    def add_task(self, task_id: str, task_func: Callable) -> None:
        """添加任务到队列"""
        # 任务将在主线程通过 bpy.app.timers 执行
        self.task_queue.put({
            'id': task_id,
            'func': task_func
        })
    
    def _process_queue(self) -> float:
        """在 Blender 主线程处理队列中的任务"""
        while not self.task_queue.empty():
            task = self.task_queue.get()
            
            # 在主线程安全执行
            try:
                result = task['func']()
                self.results[task['id']] = result
            except Exception as e:
                self.results[task['id']] = {'error': str(e)}
        
        return 0.1  # 0.1 秒后再次检查
```

---

### 1.4 协议标准

#### JSON-RPC 2.0 规范

严格遵守 JSON-RPC 2.0 规范：

```json
// 请求格式
{
    "jsonrpc": "2.0",
    "method": "tools/call",
    "params": {
        "name": "get_full_tree",
        "arguments": {
            "include_geometry": true
        }
    },
    "id": "1"
}

// 成功响应
{
    "jsonrpc": "2.0",
    "result": {
        "status": "Success",
        "data": {...}
    },
    "id": "1"
}

// 错误响应
{
    "jsonrpc": "2.0",
    "error": {
        "code": -32601,
        "message": "Method not found",
        "data": "tools/call"
    },
    "id": "1"
}
```

#### 标准错误码

| 错误码 | 名称 | 描述 |
|--------|------|------|
| -32700 | Parse error | 解析错误 |
| -32600 | Invalid Request | 无效请求 |
| -32601 | Method not found | 方法未找到 |
| -32602 | Invalid params | 无效参数 |
| -32603 | Internal error | 内部错误 |

#### SSE 传输规范

使用 Server-Sent Events 进行流式传输：

```
event: connected
data: {"status":"connected"}

event: message
data: {"task_id":"task_123","status":"success","data":{...}}

event: heartbeat
data: {}

event: error
data: {"error":"Task timeout"}
```

---

### 1.5 向后兼容

#### API 兼容性

不得修改现有功能的 API：

```python
# ❌ 错误：修改了现有函数签名
def get_output_detail_instruction(settings, new_param):  # 添加了新参数
    pass

# ✅ 正确：保持原有签名
def get_output_detail_instruction(settings):
    pass

# ✅ 正确：创建新函数
def get_output_detail_instruction_v2(settings, new_param):
    pass
```

#### 配置文件兼容性

保持 `config.json` 格式不变：

```json
// ❌ 错误：修改了现有配置结构
{
    "port": 5000,
    "ai": {
        "provider": {
            "name": "DEEPSEEK",
            "new_field": "value"  // 添加了新字段
        }
    }
}

// ✅ 正确：保持原有结构
{
    "port": 5000,
    "ai": {
        "provider": {
            "name": "DEEPSEEK"
        }
    },
    "mcp": {  // 新增独立配置块
        "enabled": true
    }
}
```

#### 路由兼容性

新增路由不得与现有路由冲突：

```python
# ❌ 错误：覆盖了现有路由
@app.route('/api/status', methods=['POST'])  # 现有是 GET
    pass

# ✅ 正确：使用新路由
@app.route('/api/mcp/status', methods=['POST'])
    pass
```

---

## 2. 测试计划

### 2.1 单元测试

#### 测试框架

使用 `unittest` 框架：

```python
import unittest
from backend.core.hierarchy import get_hierarchy

class TestHierarchy(unittest.TestCase):
    """测试资产检索模块"""
    
    def test_get_hierarchy_all(self):
        """测试获取所有资产"""
        result = get_hierarchy()
        self.assertEqual(result['status'], 'Success')
        self.assertIn('Geometry Nodes', result['data'])
    
    def test_get_hierarchy_materials_only(self):
        """测试仅获取材质"""
        result = get_hierarchy(
            include_materials=True,
            include_geometry=False
        )
        self.assertEqual(result['status'], 'Success')
        self.assertIn('Materials', result['data'])
        self.assertNotIn('Geometry Nodes', result['data'])
    
    def test_get_hierarchy_empty(self):
        """测试空场景"""
        result = get_hierarchy(
            include_materials=False,
            include_geometry=False
        )
        self.assertEqual(result['status'], 'Success')
        self.assertEqual(len(result['data']), 0)

if __name__ == '__main__':
    unittest.main()
```

#### 测试覆盖率

目标测试覆盖率：**80% 以上**

| 模块 | 覆盖率目标 |
|------|-----------|
| `hierarchy.py` | 80% |
| `module_fetcher.py` | 80% |
| `node_filter.py` | 85% |
| `node_parser.py` | 85% |
| `config_reader.py` | 75% |
| `task_queue.py` | 90% |
| `server.py` | 75% |

---

### 2.2 集成测试

#### 测试场景

| 测试场景 | 测试步骤 | 预期结果 |
|----------|----------|----------|
| MCP 服务器启动 | 启动服务器 | 服务器正常运行 |
| SSE 连接 | 连接 SSE 端点 | 成功建立连接 |
| JSON-RPC 请求 | 发送 JSON-RPC 请求 | 返回正确响应 |
| 工具调用 | 调用 MCP 工具 | 工具正确执行 |
| 任务队列 | 添加任务到队列 | 任务在主线程执行 |
| 错误处理 | 发送无效请求 | 返回错误响应 |
| 并发请求 | 同时发送多个请求 | 所有请求正确处理 |

#### 集成测试代码

```python
import unittest
import requests
import json

class TestMCPIntegration(unittest.TestCase):
    """测试 MCP 集成"""
    
    BASE_URL = "http://127.0.0.1:5000"
    
    def test_mcp_server_running(self):
        """测试 MCP 服务器运行"""
        response = requests.get(f"{self.BASE_URL}/api/status")
        self.assertEqual(response.status_code, 200)
    
    def test_sse_connection(self):
        """测试 SSE 连接"""
        response = requests.get(
            f"{self.BASE_URL}/mcp/sse",
            stream=True
        )
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers['Content-Type'], 'text/event-stream')
    
    def test_jsonrpc_request(self):
        """测试 JSON-RPC 请求"""
        request = {
            "jsonrpc": "2.0",
            "method": "tools/list",
            "id": "1"
        }
        response = requests.post(
            f"{self.BASE_URL}/mcp/rpc",
            json=request
        )
        self.assertEqual(response.status_code, 200)
        result = response.json()
        self.assertIn('result', result)
    
    def test_tool_call(self):
        """测试工具调用"""
        request = {
            "jsonrpc": "2.0",
            "method": "tools/call",
            "params": {
                "name": "get_config",
                "arguments": {
                    "config_key": "system_message_presets"
                }
            },
            "id": "1"
        }
        response = requests.post(
            f"{self.BASE_URL}/mcp/rpc",
            json=request
        )
        self.assertEqual(response.status_code, 200)
        result = response.json()
        self.assertEqual(result['result']['status'], 'Success')

if __name__ == '__main__':
    unittest.main()
```

---

### 2.3 端到端测试

#### 测试场景

| 测试场景 | 测试步骤 | 预期结果 |
|----------|----------|----------|
| Web + MCP | Web 客户端调用 MCP 工具 | 正确返回结果 |
| Blender + MCP | Blender 插件调用 MCP 工具 | 正确返回结果 |
| 并发请求 | 同时发送多个请求 | 所有请求正确处理 |
| 长时间运行 | 服务器运行 24 小时 | 无内存泄漏 |
| 错误恢复 | 服务器崩溃后重启 | 自动恢复 |

#### 性能测试

| 指标 | 目标值 | 测试方法 |
|------|--------|----------|
| MCP 服务器响应时间 | < 100ms | 发送 1000 个请求，计算平均响应时间 |
| 任务队列执行时间 | < 1s | 添加任务到队列，测量执行时间 |
| 内存占用 | < 100MB | 运行 1 小时，监控内存使用 |
| CPU 占用 | < 10% | 运行 1 小时，监控 CPU 使用 |
| 并发处理能力 | > 100 req/s | 同时发送 100 个请求 |

---

## 3. 验收标准

### 3.1 功能验收

#### 核心功能

- ✅ 所有 MCP 工具正常工作
- ✅ 任务队列正确执行
- ✅ SSE 连接稳定
- ✅ JSON-RPC 请求正确处理
- ✅ 测试面板功能正常
- ✅ 配置导出功能正常

#### 工具列表

| 工具 | 状态 | 备注 |
|------|------|------|
| `get_full_tree` | ✅ 通过 | 正确返回资产层级结构 |
| `inspect_module` | ✅ 通过 | 正确定位和解析模块 |
| `get_config` | ✅ 通过 | 正确读取配置 |
| `parse_node_tree` | ✅ 通过 | 正确解析节点树 |
| `filter_node_data` | ✅ 通过 | 正确过滤节点数据 |

---

### 3.2 性能验收

#### 响应时间

| 操作 | 目标值 | 实际值 | 状态 |
|------|--------|--------|------|
| MCP 服务器响应 | < 100ms | ___ ms | ⬜ |
| 任务队列执行 | < 1s | ___ s | ⬜ |
| 资产检索 | < 500ms | ___ ms | ⬜ |
| 模块定位 | < 200ms | ___ ms | ⬜ |
| 节点过滤 | < 100ms | ___ ms | ⬜ |

#### 资源占用

| 指标 | 目标值 | 实际值 | 状态 |
|------|--------|--------|------|
| 内存占用 | < 100MB | ___ MB | ⬜ |
| CPU 占用 | < 10% | ___ % | ⬜ |
| 线程数 | < 10 | ___ | ⬜ |

---

### 3.3 质量验收

#### 代码质量

| 指标 | 目标值 | 实际值 | 状态 |
|------|--------|--------|------|
| 单元测试覆盖率 | > 80% | ___ % | ⬜ |
| 代码符合 PEP 8 | 100% | ___ % | ⬜ |
| 函数文档字符串 | 100% | ___ % | ⬜ |
| 类型提示覆盖率 | > 90% | ___ % | ⬜ |
| 无严重 bug | 0 | ___ | ⬜ |

#### 文档质量

| 文档 | 状态 | 备注 |
|------|------|------|
| MCP 开发文档 | ✅ 完成 | |
| API 文档 | ✅ 完成 | |
| 使用指南 | ✅ 完成 | |
| 测试文档 | ✅ 完成 | |

---

### 3.4 兼容性验收

#### 功能兼容性

| 功能 | 状态 | 备注 |
|------|------|------|
| 现有 Web 功能 | ✅ 正常 | 不受影响 |
| 现有 Blender 功能 | ✅ 正常 | 不受影响 |
| 配置文件格式 | ✅ 兼容 | 保持不变 |
| API 接口 | ✅ 兼容 | 保持不变 |

#### 平台兼容性

| 平台 | 状态 | 备注 |
|------|------|------|
| Windows | ✅ 通过 | |
| macOS | ⬜ 待测试 | |
| Linux | ⬜ 待测试 | |

#### Blender 版本兼容性

| 版本 | 状态 | 备注 |
|------|------|------|
| 4.2+ | ✅ 通过 | |
| 4.1 | ⬜ 待测试 | |
| 4.0 | ⬜ 待测试 | |

---

## 4. 风险评估

### 4.1 技术风险

| 风险 | 影响 | 概率 | 缓解措施 | 状态 |
|------|------|------|----------|------|
| Blender API 线程安全问题 | 高 | 中 | 使用任务队列确保主线程执行 | ✅ 已缓解 |
| MCP 协议兼容性问题 | 中 | 低 | 严格遵循 MCP 规范 | ✅ 已缓解 |
| 性能问题 | 中 | 中 | 实现缓存和优化 | ⬜ 待验证 |
| 与现有功能冲突 | 高 | 低 | 充分测试，确保向后兼容 | ✅ 已缓解 |

### 4.2 开发风险

| 风险 | 影响 | 概率 | 缓解措施 | 状态 |
|------|------|------|----------|------|
| 开发时间超期 | 中 | 中 | 分阶段实施，及时调整 | ⬜ 待监控 |
| 代码质量问题 | 高 | 低 | 代码审查，单元测试 | ✅ 已缓解 |
| 文档不完整 | 低 | 中 | 并行编写文档 | ✅ 已缓解 |

---

## 5. 交付清单

### 5.1 代码交付

- [ ] `backend/core/hierarchy.py` - 资产检索模块
- [ ] `backend/core/module_fetcher.py` - 模块定位模块
- [ ] `backend/core/node_filter.py` - 节点过滤模块
- [ ] `backend/core/node_parser.py` - 节点解析模块
- [ ] `backend/core/config_reader.py` - 配置读取模块
- [ ] `backend/mcp/server.py` - MCP 服务器
- [ ] `backend/mcp/tools.py` - MCP 工具定义
- [ ] `backend/mcp/task_queue.py` - 任务队列管理
- [ ] `backend/mcp/config_generator.py` - 配置生成器
- [ ] `backend/mcp/protocol.py` - MCP 协议实现
- [ ] `backend/server.py` - 修改后的 Flask 服务器
- [ ] `__init__.py` - 修改后的 Blender 插件

### 5.2 文档交付

- [x] `docs/todo/00-MCP_集成项目总览.md` - 项目总览
- [x] `docs/todo/01-阶段一_功能原子化.md` - 阶段一文档
- [x] `docs/todo/02-阶段二_MCP适配器实现.md` - 阶段二文档
- [x] `docs/todo/03-阶段三_测试面板与诊断系统.md` - 阶段三文档
- [x] `docs/todo/04-技术规范与验收标准.md` - 本文档
- [ ] `docs/mcp/API文档.md` - MCP API 文档
- [ ] `docs/mcp/使用指南.md` - MCP 使用指南

### 5.3 配置交付

- [ ] `mcp_config.json` - MCP 配置模板
- [ ] `config.json` - 更新后的配置文件（保持兼容）

### 5.4 测试交付

- [ ] 单元测试代码
- [ ] 集成测试代码
- [ ] 性能测试报告
- [ ] 测试覆盖率报告

---

## 6. 附录

### 6.1 参考资料

- [Model Context Protocol 规范](https://modelcontextprotocol.io/)
- [JSON-RPC 2.0 规范](https://www.jsonrpc.org/specification)
- [Server-Sent Events 规范](https://html.spec.whatwg.org/multipage/server-sent-events.html)
- [Blender Python API 文档](https://docs.blender.org/api/current/)
- [Flask 文档](https://flask.palletsprojects.com/)
- [PEP 8 规范](https://peps.python.org/pep-0008/)

### 6.2 相关文档

- [Blender 插件总览](../blender/00-总览.md)
- [后端服务器文档](../blender/06-后端服务器文档.md)
- [Web 文档系统文档](../web/07-文档系统文档.md)
- [MCP 集成项目总览](./00-MCP_集成项目总览.md)
- [阶段一：功能原子化](./01-阶段一_功能原子化.md)
- [阶段二：MCP适配器实现](./02-阶段二_MCP适配器实现.md)
- [阶段三：测试面板与诊断系统](./03-阶段三_测试面板与诊断系统.md)

### 6.3 术语表

| 术语 | 定义 |
|------|------|
| MCP | Model Context Protocol，模型上下文协议 |
| SSE | Server-Sent Events，服务器推送事件 |
| JSON-RPC | JSON Remote Procedure Call，JSON 远程过程调用 |
| Blender API | Blender 的 Python API |
| 节点树 | Blender 中的节点编辑器数据结构 |
| 数据块 (Data-Block) | Blender 中的基本数据单元 |
| 任务队列 | 用于异步执行 Blender API 调用的队列 |
| 线程安全 | 在多线程环境下正确运行的能力 |
| 向后兼容 | 新版本不破坏旧版本功能的能力 |

---

**文档结束**
# 阶段三：测试面板与诊断系统

**文档版本**: 1.0.0
**创建日期**: 2026-01-13
**预计时间**: 1-2 天

---

## 1. 目标

在 Blender UI 中添加测试和诊断功能，方便开发者测试 MCP 功能、诊断问题，并导出配置文件。

## 2. UI 设计

### 2.1 面板结构

```
┌─────────────────────────────────────────┐
│  AI Node Analyzer                       │
├─────────────────────────────────────────┤
│  [主面板] [快速复制] [MCP 诊断]         │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│  MCP 诊断                               │
├─────────────────────────────────────────┤
│  MCP 服务器状态:                        │
│  状态: 运行中        [停止]              │
│                                          │
│  功能测试:                               │
│  [测试资产检索]                          │
│  [测试模块定位]                          │
│  [测试节点过滤]                          │
│  [测试配置读取]                          │
│                                          │
│  测试结果:                               │
│  ┌────────────────────────────────────┐ │
│  │ 资产检索测试成功:                   │ │
│  │ 找到 5 个类别                       │ │
│  └────────────────────────────────────┘ │
│                                          │
│  配置导出:                               │
│  [导出 MCP 配置]                        │
└─────────────────────────────────────────┘
```

### 2.2 新增属性

在 `AINodeAnalyzerSettings` 属性组中添加以下属性：

```python
class AINodeAnalyzerSettings(bpy.types.PropertyGroup):
    # ... 现有属性 ...
    
    # MCP 服务器状态
    mcp_server_running: bpy.props.BoolProperty(
        name="MCP 服务器运行中",
        default=False,
        description="MCP 服务器是否正在运行"
    )
    
    # MCP 测试结果
    mcp_test_result: bpy.props.StringProperty(
        name="MCP 测试结果",
        default="",
        description="MCP 功能测试的结果",
        subtype='MULTILINE_LINE'
    )
```

## 3. 详细实现

### 3.1 MCP 诊断面板

#### 面板类定义

```python
class NODE_PT_mcp_diagnostics(bpy.types.Panel):
    """MCP 诊断面板"""
    bl_label = "MCP 诊断"
    bl_idname = "NODE_PT_mcp_diagnostics"
    bl_space_type = 'NODE_EDITOR'
    bl_region_type = 'UI'
    bl_category = 'AI Node Analyzer'
    bl_options = {'DEFAULT_CLOSED'}
    
    def draw(self, context):
        layout = self.layout
        settings = context.scene.ainode_analyzer_settings
        
        # MCP 服务器状态
        box = layout.box()
        box.label(text="MCP 服务器状态:", icon='INFO')
        row = box.row()
        row.label(text=f"状态: {'运行中' if settings.mcp_server_running else '已停止'}")
        row.operator("node.toggle_mcp_server", 
                    text="停止" if settings.mcp_server_running else "启动")
        
        # 功能测试
        box = layout.box()
        box.label(text="功能测试:", icon='TEST')
        box.operator("node.mcp_test_hierarchy", text="测试资产检索")
        box.operator("node.mcp_test_module_fetch", text="测试模块定位")
        box.operator("node.mcp_test_filter", text="测试节点过滤")
        box.operator("node.mcp_test_config", text="测试配置读取")
        
        # 测试结果显示
        if settings.mcp_test_result:
            box = layout.box()
            box.label(text="测试结果:", icon='TEXT')
            col = box.column(align=True)
            for line in settings.mcp_test_result.split('\n'):
                col.label(text=line)
        
        # 配置导出
        box = layout.box()
        box.label(text="配置导出:", icon='EXPORT')
        box.operator("node.export_mcp_config", text="导出 MCP 配置")
```

---

### 3.2 测试运算符

#### 3.2.1 测试资产检索

```python
class NODE_OT_mcp_test_hierarchy(bpy.types.Operator):
    """测试 MCP 资产检索功能"""
    bl_idname = "node.mcp_test_hierarchy"
    bl_label = "测试资产检索"
    
    def execute(self, context):
        try:
            from backend.core.hierarchy import get_hierarchy
            
            # 调用资产检索
            result = get_hierarchy()
            
            # 显示结果
            settings = context.scene.ainode_analyzer_settings
            if result['status'] == 'Success':
                data = result['data']
                categories_count = len(data)
                total_items = sum(len(items) for items in data.values())
                settings.mcp_test_result = (
                    f"资产检索测试成功:\n"
                    f"找到 {categories_count} 个类别\n"
                    f"共 {total_items} 个资产"
                )
                self.report({'INFO'}, "资产检索测试成功")
            else:
                settings.mcp_test_result = f"资产检索测试失败: {result.get('error', 'Unknown error')}"
                self.report({'ERROR'}, "资产检索测试失败")
            
            return {'FINISHED'}
        except Exception as e:
            settings = context.scene.ainode_analyzer_settings
            settings.mcp_test_result = f"资产检索测试失败: {str(e)}"
            self.report({'ERROR'}, f"资产检索测试失败: {str(e)}")
            return {'CANCELLED'}
```

#### 3.2.2 测试模块定位

```python
class NODE_OT_mcp_test_module_fetch(bpy.types.Operator):
    """测试 MCP 模块定位功能"""
    bl_idname = "node.mcp_test_module_fetch"
    bl_label = "测试模块定位"
    
    def execute(self, context):
        try:
            from backend.core.module_fetcher import fetch_module
            
            # 获取第一个材质进行测试
            if bpy.data.materials:
                path = f"Materials/{bpy.data.materials[0].name}"
                result = fetch_module(path)
                
                # 显示结果
                settings = context.scene.ainode_analyzer_settings
                if result['status'] == 'Success':
                    data = result['data']
                    node_count = data.get('node_tree', {}).get('nodes_count', 0)
                    settings.mcp_test_result = (
                        f"模块定位测试成功:\n"
                        f"路径: {path}\n"
                        f"类型: {data.get('type')}\n"
                        f"节点数: {node_count}"
                    )
                    self.report({'INFO'}, "模块定位测试成功")
                else:
                    settings.mcp_test_result = f"模块定位测试失败: {result.get('error', 'Unknown error')}"
                    self.report({'ERROR'}, "模块定位测试失败")
            else:
                settings = context.scene.ainode_analyzer_settings
                settings.mcp_test_result = "模块定位测试失败: 没有找到材质进行测试"
                self.report({'WARNING'}, "没有找到材质进行测试")
            
            return {'FINISHED'}
        except Exception as e:
            settings = context.scene.ainode_analyzer_settings
            settings.mcp_test_result = f"模块定位测试失败: {str(e)}"
            self.report({'ERROR'}, f"模块定位测试失败: {str(e)}")
            return {'CANCELLED'}
```

#### 3.2.3 测试节点过滤

```python
class NODE_OT_mcp_test_filter(bpy.types.Operator):
    """测试 MCP 节点过滤功能"""
    bl_idname = "node.mcp_test_filter"
    bl_label = "测试节点过滤"
    
    def execute(self, context):
        try:
            from backend.core.node_filter import filter_node_data
            import json
            
            # 创建测试数据
            test_data = {
                "nodes": [
                    {
                        "name": "TestNode",
                        "type": "ShaderNodeBsdfPrincipled",
                        "location": [0, 0],
                        "width": 140,
                        "height": 100,
                        "color": [0.8, 0.8, 0.8, 1.0],
                        "inputs": [
                            {
                                "name": "Base Color",
                                "identifier": "Base Color",
                                "type": 'RGBA',
                                "default_value": [0.8, 0.8, 0.8, 1.0]
                            },
                            {
                                "name": "Roughness",
                                "identifier": "Roughness",
                                "type": 'FLOAT',
                                "default_value": 0.5
                            }
                        ]
                    }
                ]
            }
            
            # 测试不同过滤级别
            results = []
            for level in ['ULTRA_LITE', 'LITE', 'STANDARD', 'FULL']:
                filtered = filter_node_data(test_data, level)
                if filtered['status'] == 'Success':
                    data = filtered['data']
                    original_size = data.get('original_size', 0)
                    filtered_size = data.get('filtered_size', 0)
                    reduction_ratio = data.get('reduction_ratio', 0)
                    results.append(
                        f"{level}: {filtered_size} 字节 "
                        f"(压缩率: {reduction_ratio:.1%})"
                    )
                else:
                    results.append(f"{level}: 测试失败")
            
            # 显示结果
            settings = context.scene.ainode_analyzer_settings
            settings.mcp_test_result = "节点过滤测试成功:\n" + "\n".join(results)
            
            self.report({'INFO'}, "节点过滤测试成功")
            return {'FINISHED'}
        except Exception as e:
            settings = context.scene.ainode_analyzer_settings
            settings.mcp_test_result = f"节点过滤测试失败: {str(e)}"
            self.report({'ERROR'}, f"节点过滤测试失败: {str(e)}")
            return {'CANCELLED'}
```

#### 3.2.4 测试配置读取

```python
class NODE_OT_mcp_test_config(bpy.types.Operator):
    """测试 MCP 配置读取功能"""
    bl_idname = "node.mcp_test_config"
    bl_label = "测试配置读取"
    
    def execute(self, context):
        try:
            from backend.core.config_reader import get_config
            
            # 读取系统消息预设
            result = get_config('system_message_presets')
            
            # 显示结果
            settings = context.scene.ainode_analyzer_settings
            if result['status'] == 'Success':
                presets = result['data'].get('system_message_presets', [])
                presets_count = len(presets)
                settings.mcp_test_result = (
                    f"配置读取测试成功:\n"
                    f"找到 {presets_count} 个系统消息预设"
                )
                if presets:
                    settings.mcp_test_result += f"\n第一个预设: {presets[0].get('label', 'Unknown')}"
                self.report({'INFO'}, "配置读取测试成功")
            else:
                settings.mcp_test_result = f"配置读取测试失败: {result.get('error', 'Unknown error')}"
                self.report({'ERROR'}, "配置读取测试失败")
            
            return {'FINISHED'}
        except Exception as e:
            settings = context.scene.ainode_analyzer_settings
            settings.mcp_test_result = f"配置读取测试失败: {str(e)}"
            self.report({'ERROR'}, f"配置读取测试失败: {str(e)}")
            return {'CANCELLED'}
```

---

### 3.3 MCP 服务器控制

#### 3.3.1 切换 MCP 服务器状态

```python
class NODE_OT_toggle_mcp_server(bpy.types.Operator):
    """切换 MCP 服务器状态"""
    bl_idname = "node.toggle_mcp_server"
    bl_label = "切换 MCP 服务器"
    
    def execute(self, context):
        settings = context.scene.ainode_analyzer_settings
        
        if settings.mcp_server_running:
            # 停止服务器
            settings.mcp_server_running = False
            self.report({'INFO'}, "MCP 服务器已停止")
        else:
            # 启动服务器
            settings.mcp_server_running = True
            self.report({'INFO'}, "MCP 服务器已启动")
        
        return {'FINISHED'}
```

---

### 3.4 配置导出

#### 3.4.1 导出 MCP 配置文件

```python
class NODE_OT_export_mcp_config(bpy.types.Operator):
    """导出 MCP 配置文件"""
    bl_idname = "node.export_mcp_config"
    bl_label = "导出 MCP 配置"
    
    filepath: bpy.props.StringProperty(
        subtype='FILE_PATH',
        default="mcp_config.json"
    )
    
    def invoke(self, context, event):
        context.window_manager.fileselect_add(self)
        return {'RUNNING_MODAL'}
    
    def execute(self, context):
        try:
            import json
            import os
            
            # 获取插件目录
            addon_dir = os.path.dirname(os.path.dirname(__file__))
            
            # 读取配置
            config_path = os.path.join(addon_dir, 'config.json')
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)
            
            # 生成 MCP 配置
            mcp_config = {
                "mcpServers": {
                    "blender-analyzer": {
                        "transport": {
                            "type": "sse",
                            "url": f"http://127.0.0.1:{config.get('port', 5000)}/mcp/sse"
                        },
                        "capabilities": {
                            "tools": [
                                "get_full_tree",
                                "inspect_module",
                                "get_config",
                                "parse_node_tree",
                                "filter_node_data"
                            ]
                        },
                        "timeout": 30
                    }
                }
            }
            
            # 写入文件
            with open(self.filepath, 'w', encoding='utf-8') as f:
                json.dump(mcp_config, f, indent=4, ensure_ascii=False)
            
            self.report({'INFO'}, f"MCP 配置已导出到: {self.filepath}")
            return {'FINISHED'}
        except Exception as e:
            self.report({'ERROR'}, f"导出 MCP 配置失败: {str(e)}")
            return {'CANCELLED'}
```

---

### 3.5 配置生成器模块

#### 创建 `backend/mcp/config_generator.py`

```python
import json
import os

def generate_mcp_config(output_path: str = None) -> str:
    """
    生成 MCP 配置文件
    
    Args:
        output_path (str): 输出文件路径，默认为插件目录下的 mcp_config.json
    
    Returns:
        str: 生成的配置文件路径
    """
    # 获取插件目录
    addon_dir = os.path.dirname(os.path.dirname(__file__))
    
    # 读取当前配置
    config_path = os.path.join(addon_dir, 'config.json')
    with open(config_path, 'r', encoding='utf-8') as f:
        config = json.load(f)
    
    # 生成 MCP 配置
    mcp_config = {
        "mcpServers": {
            "blender-analyzer": {
                "transport": {
                    "type": "sse",
                    "url": f"http://127.0.0.1:{config.get('port', 5000)}/mcp/sse"
                },
                "capabilities": {
                    "tools": [
                        "get_full_tree",
                        "inspect_module",
                        "get_config",
                        "parse_node_tree",
                        "filter_node_data"
                    ]
                },
                "timeout": 30
            }
        }
    }
    
    # 确定输出路径
    if output_path is None:
        output_path = os.path.join(addon_dir, 'mcp_config.json')
    
    # 写入文件
    with open(output_path, 'w', encoding='utf-8') as f:
        json.dump(mcp_config, f, indent=4, ensure_ascii=False)
    
    return output_path
```

---

## 4. 注册新组件

### 4.1 修改 `register()` 函数

```python
def register():
    # ... 现有注册代码 ...
    
    # 注册 MCP 诊断面板
    bpy.utils.register_class(NODE_PT_mcp_diagnostics)
    
    # 注册 MCP 测试运算符
    bpy.utils.register_class(NODE_OT_mcp_test_hierarchy)
    bpy.utils.register_class(NODE_OT_mcp_test_module_fetch)
    bpy.utils.register_class(NODE_OT_mcp_test_filter)
    bpy.utils.register_class(NODE_OT_mcp_test_config)
    
    # 注册 MCP 服务器控制运算符
    bpy.utils.register_class(NODE_OT_toggle_mcp_server)
    
    # 注册配置导出运算符
    bpy.utils.register_class(NODE_OT_export_mcp_config)
```

### 4.2 修改 `unregister()` 函数

```python
def unregister():
    # ... 现有注销代码 ...
    
    # 注销 MCP 诊断面板
    bpy.utils.unregister_class(NODE_PT_mcp_diagnostics)
    
    # 注销 MCP 测试运算符
    bpy.utils.unregister_class(NODE_OT_mcp_test_hierarchy)
    bpy.utils.unregister_class(NODE_OT_mcp_test_module_fetch)
    bpy.utils.unregister_class(NODE_OT_mcp_test_filter)
    bpy.utils.unregister_class(NODE_OT_mcp_test_config)
    
    # 注销 MCP 服务器控制运算符
    bpy.utils.unregister_class(NODE_OT_toggle_mcp_server)
    
    # 注销配置导出运算符
    bpy.utils.unregister_class(NODE_OT_export_mcp_config)
```

---

## 5. 实施步骤

### 步骤 1: 添加 MCP 相关属性

1. 修改 `__init__.py`
2. 在 `AINodeAnalyzerSettings` 类中添加 `mcp_server_running` 属性
3. 在 `AINodeAnalyzerSettings` 类中添加 `mcp_test_result` 属性

### 步骤 2: 实现 MCP 诊断面板

1. 修改 `__init__.py`
2. 添加 `NODE_PT_mcp_diagnostics` 面板类
3. 实现面板 UI

### 步骤 3: 实现测试运算符

1. 修改 `__init__.py`
2. 添加 `NODE_OT_mcp_test_hierarchy` 运算符
3. 添加 `NODE_OT_mcp_test_module_fetch` 运算符
4. 添加 `NODE_OT_mcp_test_filter` 运算符
5. 添加 `NODE_OT_mcp_test_config` 运算符

### 步骤 4: 实现 MCP 服务器控制运算符

1. 修改 `__init__.py`
2. 添加 `NODE_OT_toggle_mcp_server` 运算符

### 步骤 5: 实现配置导出功能

1. 创建 `backend/mcp/config_generator.py`
2. 修改 `__init__.py`
3. 添加 `NODE_OT_export_mcp_config` 运算符

### 步骤 6: 注册新组件

1. 修改 `register()` 函数
2. 注册所有新增的类和运算符
3. 修改 `unregister()` 函数

### 步骤 7: UI 测试

1. 在 Blender 中加载插件
2. 打开节点编辑器
3. 查看 MCP 诊断面板
4. 测试所有测试按钮
5. 测试配置导出

---

## 6. 测试用例

### 6.1 测试资产检索

```python
# 测试步骤
1. 打开 Blender
2. 创建一些材质、几何节点组等
3. 打开节点编辑器
4. 找到 "MCP 诊断" 面板
5. 点击 "测试资产检索" 按钮
6. 检查测试结果

# 预期结果
- 测试结果显示成功
- 显示找到的类别数量
- 显示找到的资产总数
```

### 6.2 测试模块定位

```python
# 测试步骤
1. 打开 Blender
2. 创建一个材质
3. 打开节点编辑器
4. 找到 "MCP 诊断" 面板
5. 点击 "测试模块定位" 按钮
6. 检查测试结果

# 预期结果
- 测试结果显示成功
- 显示定位的路径
- 显示资产类型
- 显示节点数量
```

### 6.3 测试节点过滤

```python
# 测试步骤
1. 打开 Blender
2. 打开节点编辑器
3. 找到 "MCP 诊断" 面板
4. 点击 "测试节点过滤" 按钮
5. 检查测试结果

# 预期结果
- 测试结果显示成功
- 显示所有过滤级别的结果
- 显示每个级别的压缩率
```

### 6.4 测试配置读取

```python
# 测试步骤
1. 打开 Blender
2. 打开节点编辑器
3. 找到 "MCP 诊断" 面板
4. 点击 "测试配置读取" 按钮
5. 检查测试结果

# 预期结果
- 测试结果显示成功
- 显示找到的预设数量
- 显示第一个预设的名称
```

### 6.5 测试配置导出

```python
# 测试步骤
1. 打开 Blender
2. 打开节点编辑器
3. 找到 "MCP 诊断" 面板
4. 点击 "导出 MCP 配置" 按钮
5. 选择保存位置
6. 检查导出的文件

# 预期结果
- 文件成功导出
- 文件包含正确的 MCP 配置
- 配置包含正确的 URL 和端口
```

---

## 7. 验收标准

### 7.1 功能验收

- ✅ MCP 诊断面板正常显示
- ✅ 所有测试按钮正常工作
- ✅ 测试结果正确显示
- ✅ 配置导出功能正常
- ✅ MCP 服务器状态正确显示

### 7.2 UI 验收

- ✅ 面板布局合理
- ✅ 按钮标签清晰
- ✅ 测试结果可读性好
- ✅ 错误信息清晰

### 7.3 兼容性验收

- ✅ 不影响现有面板
- ✅ 不影响现有功能
- ✅ 可以独立使用

---

**文档结束**
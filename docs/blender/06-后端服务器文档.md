# 后端服务器文档

## 服务器信息

| 属性 | 值 |
|------|-----|
| 框架 | Flask |
| 端口 | 默认 5000（可配置） |
| 静态文件夹 | `chatgpt-web/dist` |
| 跨域支持 | 是（CORS） |

## 文件结构

```
backend/
├── server.py              # Flask 后端服务器（1954行）
├── ai_note.py             # 文本注记节点
└── api/
    └── blender_api.py     # Blender API
```

## 1. server.py

### 1.1 初始化

**代码位置**：`backend/server.py` 第 1-80 行

**功能**：
- 导入必要的库（Flask, Flask-CORS, requests）
- 自动安装缺失的依赖
- 初始化配置文件
- 设置静态文件夹路径
- 启用 CORS

```python
import json
import threading
import sys
import os
import uuid
import time
import requests

try:
    from flask import Flask, request, jsonify, send_from_directory, Response, stream_with_context
    from flask_cors import CORS
except ImportError:
    print("正在安装Flask依赖...")
    import subprocess
    blender_python_path = sys.executable
    subprocess.check_call([blender_python_path, "-m", "pip", "install", "flask", "flask-cors", "requests"])
    from flask import Flask, request, jsonify, send_from_directory, Response, stream_with_context
    from flask_cors import CORS

app = Flask(__name__, static_folder=static_folder_path, static_url_path='')
CORS(app)
```

### 1.2 全局变量

**代码位置**：`backend/server.py` 第 82-103 行

```python
# 存储Blender数据的全局变量
blender_data = {
    "nodes": "",
    "status": "disconnected",
    "current_operation": None,
    "type": "initial",
    "filename": "Unknown",
    "version": "",
    "node_type": "",
    "tokens": 0
}

# Sync flags
pending_updates = {}
refresh_flag = False

# 存储对话历史
conversations = {}
current_conversation_id = None
conversation_memory = {}
conversation_stats = {}
```

### 1.3 路由端点

#### 1.3.1 静态文件服务

**代码位置**：`backend/server.py` 第 105-130 行

```python
@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def serve(path):
    if path != "" and os.path.exists(os.path.join(app.static_folder, path)):
        response = send_from_directory(app.static_folder, path)
    else:
        response = send_from_directory(app.static_folder, 'index.html')
    
    # 禁用缓存
    if path == "" or path == "index.html" or path.endswith('.html'):
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
    
    return response
```

#### 1.3.2 测试联网

**代码位置**：`backend/server.py` 第 132-160 行

```python
@app.route('/api/test-networking', methods=['GET'])
def test_networking():
    urls = [
        "https://httpbin.org/get",
        "https://api.ipify.org?format=json",
        "https://api.github.com"
    ]
    results = []
    capable = False
    for u in urls:
        ok = False
        status_code = 0
        try:
            r = requests.get(u, timeout=5)
            status_code = r.status_code
            ok = (r.status_code == 200)
        except Exception:
            pass
        results.append({"url": u, "status_code": status_code, "ok": ok})
        if ok:
            capable = True
    return jsonify({"capable": capable, "results": results})
```

#### 1.3.3 获取设置

**代码位置**：`backend/server.py` 第 162-230 行

```python
def get_settings():
    """从Blender获取设置"""
    settings = {}
    try:
        import bpy
        # 尝试获取当前场景
        scene = None
        if hasattr(bpy, 'context') and hasattr(bpy.context, 'scene'):
            scene = bpy.context.scene
        
        if not scene and hasattr(bpy, 'data') and hasattr(bpy.data, 'scenes') and len(bpy.data.scenes) > 0:
            scene = bpy.data.scenes[0]
        
        if scene and hasattr(scene, 'ainode_analyzer_settings'):
            s = scene.ainode_analyzer_settings
            settings['deepseek_api_key'] = s.deepseek_api_key
            settings['deepseek_model'] = s.deepseek_model
            settings['ollama_url'] = s.ollama_url
            settings['ollama_model'] = s.ollama_model
            settings['bigmodel_api_key'] = s.bigmodel_api_key
            settings['bigmodel_url'] = s.bigmodel_url
            settings['bigmodel_model'] = s.bigmodel_model
            settings['system_prompt'] = s.system_prompt
            settings['ai_provider'] = s.ai_provider
            # ... 更多设置
        
        # 从配置文件合并设置
        # ...
    except Exception as e:
        print(f"Error getting settings from Blender: {e}")
    return settings
```

#### 1.3.4 其他 API 端点

| 端点 | 方法 | 功能 |
|------|------|------|
| `/api/blender-data` | POST | 接收 Blender 节点数据 |
| `/api/check-refresh-request` | GET | 检查刷新请求 |
| `/api/clean-markdown` | POST | 清理 Markdown 格式 |
| `/api/provider-connectivity` | POST | 测试服务商连通性 |
| `/api/provider-list-models` | POST | 获取可用模型列表 |
| `/api/test-bigmodel-api` | POST | 测试 BigModel API |
| `/api/stream-analyze` | POST | 流式 AI 分析 |
| `/api/get-web-content` | GET | 获取 Web 推送内容 |
| `/api/get-analysis-result` | GET | 获取分析结果 |
| `/api/clear-analysis-result` | POST | 清除分析结果 |

### 1.4 工具函数

#### success_response(data, message)

**代码位置**：`backend/server.py` 第 132 行

```python
def success_response(data=None, message=""):
    return jsonify({
        "status": "Success",
        "message": message,
        "data": data
    })
```

#### error_response(message, code)

**代码位置**：`backend/server.py` 第 140 行

```python
def error_response(message="Error", code=400):
    return jsonify({
        "status": "Fail",
        "message": message,
        "data": None
    }), code
```

### 1.5 服务器管理

#### ServerManager 类

**代码位置**：`backend/server.py` 第 1954 行

**功能**：
- 启动/停止服务器
- 管理服务器状态
- 处理多线程

```python
class ServerManager:
    def __init__(self):
        self.server = None
        self.thread = None
        self.is_running = False
        self.port = 5000
    
    def start_server(self, port):
        """启动服务器"""
        if self.is_running:
            return False
        
        self.port = port
        self.thread = threading.Thread(target=self._run_server)
        self.thread.daemon = True
        self.thread.start()
        
        # 等待服务器启动
        time.sleep(1)
        self.is_running = True
        return True
    
    def stop_server(self):
        """停止服务器"""
        if not self.is_running:
            return False
        
        self.is_running = False
        if self.thread:
            self.thread.join(timeout=2)
        return True
    
    def _run_server(self):
        """运行服务器"""
        app.run(host='127.0.0.1', port=self.port, debug=False, use_reloader=False)
```

---

## 2. ai_note.py

### 2.1 文本注记节点

**代码位置**：`backend/ai_note.py` 第 1-200 行

**功能**：
- 在节点编辑器中创建文本注记节点
- 显示文本内容
- 支持颜色自定义
- 自动调整宽度

```python
class AINodeTextNote(bpy.types.Node):
    bl_idname = 'AINodeTextNote'
    bl_label = "Note"
    bl_icon = 'TEXT'
    text_name: _bp.StringProperty()
    
    def get_ui_color(self):
        return self.color
    
    def set_ui_color(self, value):
        self.color = value
        self.use_custom_color = True
    
    ui_color: _bp.FloatVectorProperty(
        name="Color", 
        subtype='COLOR', 
        default=(0.0, 0.0, 0.0), 
        min=0.0, 
        max=1.0, 
        get=get_ui_color, 
        set=set_ui_color
    )
    
    def init(self, context):
        self.width = 200
        self.use_custom_color = True
        prefs = get_preferences()
        if prefs:
            try:
                self.color = prefs.default_color
            except Exception:
                pass
    
    def draw_buttons(self, context, layout):
        txt = bpy.data.texts.get(self.text_name)
        row = layout.row(align=True)
        row.operator("ainode.open_editor", text="Open")
        row.operator("ainode.fit_width", text="Fit")
        row.operator("ainode.paste_clipboard", text="Paste")
        # ... 显示文本内容
```

### 2.2 偏好设置

**代码位置**：`backend/ai_note.py` 第 200-230 行

```python
class AINODE_Preferences(AddonPreferences):
    bl_idname = 'ainode'
    editor_width: _bp.IntProperty(default=600, min=200, max=1600)
    editor_height: _bp.IntProperty(default=500, min=200, max=1200)
    default_color: _bp.FloatVectorProperty(subtype='COLOR', default=(0.0, 0.0, 0.0), min=0.0, max=1.0)
    
    def draw(self, context):
        layout = self.layout
        layout.prop(self, "editor_width", text="Editor Width")
        layout.prop(self, "editor_height", text="Editor Height")
        layout.prop(self, "default_color", text="Default Color")
```

### 2.3 运算符

| 运算符 | 功能 |
|--------|------|
| `AINODE_OT_open_editor` | 打开文本编辑器 |
| `AINODE_OT_close_window` | 关闭窗口 |
| `AINODE_OT_paste_clipboard` | 从剪贴板粘贴 |
| `AINODE_OT_fit_width` | 自动调整宽度 |

### 2.4 工具函数

#### get_preferences()

**代码位置**：`backend/ai_note.py` 第 232-239 行

```python
def get_preferences():
    try:
        return bpy.context.preferences.addons.get('ainode').preferences
    except Exception:
        return None
```

#### ensure_registered()

**代码位置**：`backend/ai_note.py` 第 242-262 行

```python
def ensure_registered():
    try:
        if not hasattr(bpy.types, 'AINodeTextNote'):
            _bu.register_class(AINodeTextNote)
        if not hasattr(bpy.types, 'AINODE_Preferences'):
            _bu.register_class(AINODE_Preferences)
        # ... 注册运算符和面板
    except Exception:
        pass
```

#### create_note(text)

**代码位置**：`backend/ai_note.py` 第 280-310 行

```python
def create_note(text):
    ensure_registered()
    tree, space, area = _get_tree_and_space()
    if not tree:
        return False
    try:
        node = tree.nodes.new('AINodeTextNote')
    except Exception:
        return False
    node.label = '注记'
    try:
        txt_block = bpy.data.texts.new(name='注记')
    except Exception:
        txt_block = None
    if txt_block:
        txt_block.use_fake_user = True
        txt_block.from_string(text)
        node.text_name = txt_block.name
    return True
```

---

## 3. API 端点详解

### 3.1 /api/blender-data

**方法**：POST

**功能**：接收 Blender 节点数据

**请求体**：
```json
{
  "nodes": "节点数据",
  "type": "refresh_content",
  "timestamp": "时间戳",
  "filename": "文件名",
  "version": "Blender版本",
  "node_type": "节点类型",
  "tokens": 1000
}
```

**响应**：
```json
{
  "status": "Success",
  "message": "数据已接收",
  "data": null
}
```

### 3.2 /api/stream-analyze

**方法**：POST

**功能**：流式 AI 分析

**请求体**：
```json
{
  "question": "问题",
  "content": "节点数据",
  "ai_provider": "DEEPSEEK",
  "ai_model": "deepseek-chat",
  "ai": {
    "thinking": {"enabled": false},
    "networking": {"enabled": true},
    "memory": {"enabled": true, "target_k": 4}
  },
  "nodeContextActive": true
}
```

**响应**（流式）：
```
data: {"type": "thinking", "content": "思考内容"}
data: {"type": "chunk", "content": "回答内容"}
data: {"type": "error", "content": "错误信息"}
data: [DONE]
```

### 3.3 /api/provider-connectivity

**方法**：POST

**功能**：测试服务商连通性

**请求体**：
```json
{
  "provider": "DEEPSEEK"
}
```

**响应**：
```json
{
  "status": "Success",
  "message": "",
  "data": {
    "ok": true
  }
}
```

### 3.4 /api/provider-list-models

**方法**：POST

**功能**：获取可用模型列表

**请求体**：
```json
{
  "provider": "DEEPSEEK"
}
```

**响应**：
```json
{
  "status": "Success",
  "message": "",
  "data": {
    "models": ["deepseek-chat", "deepseek-reasoner"]
  }
}
```

---

## 4. 与 Blender 的通信

### 4.1 Blender → 后端

**方式**：通过 `send_to_backend()` 函数

**代码位置**：`__init__.py` 第 320-358 行

```python
def send_to_backend(endpoint, data=None, method='GET'):
    """向后端发送请求"""
    global server_manager
    if not server_manager or not server_manager.is_running:
        print("后端服务器未运行")
        return None

    try:
        import requests
        url = f"http://127.0.0.1:{server_manager.port}{endpoint}"

        if method == 'POST':
            response = requests.post(url, json=data, timeout=5)
        else:
            response = requests.get(url, timeout=5)

        if response.status_code == 200:
            return response.json()
        else:
            print(f"请求失败: {response.status_code} - {response.text}")
            return None
    except Exception as e:
        print(f"发送请求到后端时出错: {e}")
        return None
```

### 4.2 后端 → Blender

**方式**：通过刷新检查器（`refresh_checker()`）

**代码位置**：`__init__.py` 第 4390-4568 行

```python
def refresh_checker():
    """定时检查是否有来自前端的请求"""
    global server_manager
    if server_manager and server_manager.is_running:
        # 检查刷新请求
        response_json = send_to_backend('/api/check-refresh-request', method='GET')
        # ... 处理刷新请求
        
        # 检查设置更新
        # ... 处理设置更新
        
        # 检查 Web 推送内容
        # ... 处理 Web 推送内容
        
        # 检查分析结果
        # ... 处理分析结果
    
    # 自动切换身份预设
    # ... 处理身份预设切换
    
    # 继续下一次检查
    return 1.0
```

---

## 5. 启动和停止

### 5.1 启动服务器

**方式**：通过 `NODE_OT_toggle_backend_server` 运算符

**代码位置**：`__init__.py` 第 1763-1791 行

```python
class NODE_OT_toggle_backend_server(bpy.types.Operator):
    bl_idname = "node.toggle_backend_server"
    bl_label = "切换后端服务器"
    
    def execute(self, context):
        global server_manager
        ain_settings = context.scene.ainode_analyzer_settings

        if server_manager:
            if server_manager.is_running:
                server_manager.stop_server()
                ain_settings.current_status = "后端已停止"
                ain_settings.enable_backend = False
                self.report({'INFO'}, "后端服务器已停止")
            else:
                port = ain_settings.backend_port
                success = server_manager.start_server(port)
                if success:
                    ain_settings.current_status = f"后端已启动 (端口: {port})"
                    ain_settings.enable_backend = True
                    self.report({'INFO'}, f"后端服务器已启动，端口: {port}")
                else:
                    ain_settings.current_status = "后端启动失败"
                    self.report({'ERROR'}, "后端服务器启动失败")
        else:
            self.report({'ERROR'}, "后端服务器未初始化")

        return {'FINISHED'}
```

### 5.2 停止服务器

**方式**：同上，再次点击切换按钮

### 5.3 访问 Web 界面

**方式**：通过 `NODE_OT_open_backend_webpage` 运算符

**代码位置**：`__init__.py` 第 2795-2813 行

```python
class NODE_OT_open_backend_webpage(bpy.types.Operator):
    bl_idname = "node.open_backend_webpage"
    bl_label = "打开后端网页"
    
    def execute(self, context):
        import webbrowser
        global server_manager
        ain_settings = context.scene.ainode_analyzer_settings

        if server_manager and server_manager.is_running:
            port = server_manager.port
            url = f"http://127.0.0.1:{port}"
            webbrowser.open(url)
            self.report({'INFO'}, f"在浏览器中打开: {url}")
        else:
            self.report({'WARNING'}, "请先启动后端服务器")

        return {'FINISHED'}
```

---

## 6. 配置文件

### 6.1 config.json

**位置**：插件根目录

**结构**：
```json
{
  "port": 5000,
  "ai": {
    "provider": {
      "name": "DEEPSEEK",
      "model": "deepseek-chat"
    },
    "deepseek": {
      "api_key": "",
      "model": "deepseek-chat",
      "url": "https://api.deepseek.com",
      "models": []
    },
    "ollama": {
      "url": "http://localhost:11434",
      "model": "llama2",
      "models": []
    },
    "bigmodel": {
      "api_key": "",
      "model": "glm-4",
      "url": "https://open.bigmodel.cn/api/paas/v4",
      "models": []
    },
    "system_prompt": "您是Blender节点的专家。分析以下节点结构并提供见解、优化或解释。",
    "temperature": 0.7,
    "top_p": 1.0,
    "memory": {
      "enabled": true,
      "target_k": 4
    },
    "thinking": {
      "enabled": false
    },
    "system_message_presets": [],
    "default_question_presets": [],
    "output_detail_presets": {
      "simple": "请简要说明，不需要使用markdown格式，简单描述即可。",
      "medium": "请按常规方式回答，使用适当的markdown格式来组织内容。",
      "detailed": "请详细说明，使用图表、列表、代码块等markdown格式来清晰地表达内容。"
    },
    "output_detail_level": "medium"
  }
}
```

### 6.2 config.example.json

**位置**：插件根目录

**用途**：配置文件示例，用于初始化 `config.json`

---

## 7. 调试

### 7.1 查看服务器日志

服务器日志会在 Blender 控制台中输出。

### 7.2 测试 API 端点

使用 `curl` 或 Postman 测试 API 端点：

```bash
# 测试服务器是否运行
curl http://127.0.0.1:5000/

# 测试联网
curl http://127.0.0.1:5000/api/test-networking
```

### 7.3 常见问题

| 问题 | 解决方案 |
|------|----------|
| 服务器无法启动 | 检查端口是否被占用 |
| 无法连接到服务器 | 确认服务器已启动 |
| API 返回错误 | 检查配置文件和 API 密钥 |